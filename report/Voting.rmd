---
title: "North Carolina Voting Data Analysis"
subtitle: "Team Multicollinearity"
author: "Abhisek Baral, Ravitashaw Bathla, Yiran (Becky) Chen, Nathan Warren, Jiayue (JY) Xu"
date: "10/29/2019"
output: pdf_document
---
  
```{r setup, include=FALSE}
# Loading required libraries
knitr::opts_chunk$set(echo = TRUE)
#knitr::opts_chunk$set(out.height='150px', dpi=200, warning=FALSE)
library(knitr)
library(dplyr)
library(ggplot2)
library(lattice)
library(rms)
library(gridExtra)
library(xtable)
library(arm)
library(pROC)
library(e1071)
library(caret)
library(lme4)
library(rlist)
library(sjPlot)
library(broom)
```

```{r data, include = FALSE}
# Loading data
getwd()
setwd("../Data/Part_2/")
sample_voting2016 <- read.csv("sample_voting2016.csv", header= T)
```

* * *
  
# Summary

A study of the residents of North Carolina across different counties was performed to analyze the voting turnout rate across differrent demographics. It was observed that the results were statistically significant in determining the odds of turnout for each person based upon different demographics. The people older than 40 years had a significantly higher turnout rate for voting than people below 40 years of age. Across the population, males were less likely to vote over females by 40 percent. However, the difference between voters turnout narrowed between the genders as the age increases until the age of 65 years. Thereafter, older men (66+) were more likely to vote than older women. Across parties, the increase in odds from males to females are two times more for democrat compared to Unaffiliated, and three times more compared to Liberatians or Republicans.  The people with undesignated gender had higher voting turnout than other genders but they represented only 1.3 percent of the total population.

# 1. Introduction
  
This study aims to analyze the data obtained from the North Carolina State Board of Elections (NCSBE) for 20 counties (Appendix 1) of North Carolina to see who voted and who did not vote for the 2016 presidential elections across different demographics. In addition, the probability of voting across different counties are analyzed. We will further be studying how the voting turnout rates differ across demographics groups for different party affiliations.

Section 2 describes the data transformation and the exploratory data analysis to understand the data based upon individual factors. In Section 3, the process of final model building is described, and the final model is presented. The evaluation of the final model and the statistical significance of individual parameters are also discussed in Secion 4. Section 5 and 6 presents the summarized results that were obtained from the model selection and the conclusions that can be infered from the relationship. The limitations of the model and the dataset are described in the final section.

# 2. Data

There were two separate datasets - registered voter data (*registered*) and the actual voting data (*voted*) across different demographics of North Carolina state for all the counties. The dataset is not a record of individual person of whether they turnout for voting or not. Instead, the dataset represents the aggregrated actual voter and total registered voter counts across different demographic groups like county, precinct, age group, gender etc.

## Data Preparation and Cleaning

The 'registered' data has voting information for different demographics with total number of registered voters. In contrast, the 'voted' data has information with total number of voters who actually voted in the 2016 presidential elections. In order to calculate the turnout of the voters, the two dataset had to be joined together to calculate the turnout rate of voting across different demographic and geographic sub-groups.

Before joining the two datasets, several steps were performed to remove the blank or empty values from both the data sets for fields which comprised of approximately 4.1 percent of the data combined. After removing the records with empty values, there were a few fields which did not provide any additional information and does not seem to play any significant role in determining the turnout rate of voters. Therefore, the columns - election_date, update_date, stats_type, voting_method, voting_method_desc - were removed from the data for further consideration. Removing these undesired columns resulted in multiple records within same demographic and geographic sub-groups. Hence, the voted data had to be aggregated for based up on the remaining 8 columns (county_desc, precinct_abbrv, vtd_abbrv, party_cd, race_code, ethnic_code, sex_code, age) common in both the datasets. This aggregation step provided us unique groups with voting count for different demographic and geographic across the state.

The resulting voted data from aggregation step was then joined with the registered data resulting in a single dataset- with the total number of registered voters and number of voters who actually voted, separated by different demographic for all the counties. 

For the purpose of this study, 20 out of the 100 counties were selected at random for analysis after data cleaning and data preparation step (ref Appendix 1). A random sample of 20 counties selected which represents 12 percent of the total population of 100 counties of North Carolina. 

There was inconsistency in the data set as there were 363 subgroups which had actual number of voters more than the people who were registered to vote. It is assumed that all the voters voted within their own registered precincts and these 1.4 percent of the total population of 20 counties were therefore removed.

## Data Transformation

A new calculated field 'non-voter' is added in the final data set for exploratory data analysis and model building. This field represents the number of people who were registerd to vote but did not actually vote in the 2016 elections. 

## Exploratory Data Analysis

The overall voting turnout for the 20 counties of North Carolina was 67.5 percent. The voter turnout across the 20 counties was almost normally distributed. The median of the voters turnout rate across these couties was 70 percent with a standard deviation of 6 percent. A majority of the counties have a voting turnout rate around the median and there a couple of counties which are deviating significantly from the median. The county Chatham has a much higher voting turnout rate of close to 80 percent. The county Robeson and Onslow has a low voting turnout rate of around 55 percent. This suggests that county difference is likely to affect voter turnout rate, and certain counties may share similiarities in voter turnout rate, which might stem from geographical adjancencies or historical reasons.

Within each county, the spread of the voting turnout across precincts varies. Alamance county has the largest voting turnout rate across different precincts ranging from 58 percent to 87 percent. Graham county had lowest voting turnout rate varying across different precincts from 64 percent to 72 percent. The number of precinct in counties varies from 4 to 40 with a median of 17 precincts. There were around 45 precincts across which the actual number of voters was less than 500 people across different demographics. This implies that there can be similarities among different precincts of the same counties and the relationship of voters turnout within the county can be shared where the population of registered and actual voters is small. 

```{r eda_county, include = FALSE}
sum(sample_voting2016$actual_voters)/sum(sample_voting2016$total_voters)

eda_county <- aggregate(sample_voting2016$actual_voters, by=list(sample_voting2016$county_desc), FUN=sum)
colnames(eda_county) <- c("county_desc", "actual_voters")
eda_county$non_voters <- aggregate(sample_voting2016$non_voters, by=list(sample_voting2016$county_desc), FUN=sum)[,2]
eda_county$total_voters <- aggregate(sample_voting2016$total_voters, by=list(sample_voting2016$county_desc), FUN=sum)[,2]
eda_county$voter_turnout <- eda_county$actual_voters/eda_county$total_voters
eda_county

#Almost Normally distributed 
hist(eda_county$voter_turnout)
median(eda_county$voter_turnout)
sd(eda_county$voter_turnout) 

# scatter binned plot --> better: significant separation among 2 groups of counties
ggplot(eda_county,
       aes(y=voter_turnout,x=county_desc,color=county_desc))+
  geom_point()+
  ylim(0.5, 0.9)
# bar plot
ggplot(eda_county,
       aes(y=voter_turnout,x=county_desc,fill=county_desc))+
  geom_bar(stat="identity", width=0.3)
```


```{r eda_precinct, include = FALSE}
eda_precinct <- aggregate(sample_voting2016$actual_voters, by=list(sample_voting2016$county_desc, sample_voting2016$precinct_abbrv), FUN=sum)
colnames(eda_precinct) <- c("county_desc","precinct_abbrv", "actual_voters")
eda_precinct$non_voters <- aggregate(sample_voting2016$non_voters, by=list(sample_voting2016$county_desc, sample_voting2016$precinct_abbrv), FUN=sum)[,3]
eda_precinct$total_voters <- aggregate(sample_voting2016$total_voters, by=list(sample_voting2016$county_desc, sample_voting2016$precinct_abbrv), FUN=sum)[,3]
eda_precinct$voter_turnout <- eda_precinct$actual_voters/eda_precinct$total_voters
eda_precinct
# scatter binned plot: significantly different distribution among different counties
ggplot(eda_precinct,
       aes(y=voter_turnout,x=county_desc,fill=county_desc))+
  geom_boxplot()+
  ylim(0.5, 0.9)

# count of precinct per county
aggregate(precinct_abbrv ~ county_desc, sample_voting2016, function(x) length(unique(x)))

```

The overall distribution of male and female population was slighlt skewed towards female with 54 percent of the total population. However, the voting turnout rate across male and female gender was 66 percent and 68 percent respectively. There were around 1.3 percent of the population who did not disclose their gender and the voting turnout ratio for these group of people was relatively higher at 72 percent. 

```{r eda_sex, include = FALSE}
eda_sex <- aggregate(sample_voting2016$actual_voters, by=list(sample_voting2016$sex_code), FUN=sum)
colnames(eda_sex) <- c("sex_code", "actual_voters")
eda_sex$non_voters <- aggregate(sample_voting2016$non_voters, by=list(sample_voting2016$sex_code), FUN=sum)[,2]
eda_sex$total_voters <- aggregate(sample_voting2016$total_voters, by=list(sample_voting2016$sex_code), FUN=sum)[,2]
eda_sex$voter_turnout <- eda_sex$actual_voters/eda_sex$total_voters
eda_sex
# scatter binned plot --> better: moderate separation between male and female
ggplot(eda_sex,
       aes(y=voter_turnout,x=sex_code,color=sex_code))+
  geom_point()+
  ylim(0.5, 0.9)
# bar plot
ggplot(eda_sex,
       aes(y=voter_turnout,x=sex_code,fill=sex_code))+
  geom_bar(stat="identity", width=0.3)
```

The population of North Carolina has a median age of 38.8 years (reference https://datausa.io/profile/geo/north-carolina). The sample data roughly mimics the population of North Carolina with 66 percent of population above 41 years of age. The number of people in the age group of 26 - 40 years is 23 percent and only 10 percent of the total population is in the age group of 18-25 years. Considering the difference in the voter turnout for people in the age group of above and below 40 years have turnout rate of around 75 percent and 54 percent respectively, suggesting that older people are more likely to vote than the younger people. 

```{r eda_age, include = FALSE}
eda_age <- aggregate(sample_voting2016$actual_voters, by=list(sample_voting2016$age), FUN=sum)
colnames(eda_age) <- c("age", "actual_voters")
eda_age$non_voters <- aggregate(sample_voting2016$non_voters, by=list(sample_voting2016$age), FUN=sum)[,2]
eda_age$total_voters <- aggregate(sample_voting2016$total_voters, by=list(sample_voting2016$age), FUN=sum)[,2]
eda_age$voter_turnout <- eda_age$actual_voters/eda_age$total_voters
eda_age
# scatter binned plot: significant separation between below 40 and above 40 age groups
ggplot(eda_age,
       aes(y=voter_turnout,x=age,color=age))+
  geom_point()+
  ylim(0.5, 0.9)
```


Across different age groups, the female population had a higher turnout rate except for the age group of people over 66 years old. The difference in voter turnout between genders narrowed as age increases until the age of 65. Combining historical contexts, it might be the case that this was the first time in the history of the United States that a women was running for the presidential elections leading to a higher voting turnout rate for females. On the other hand, older men aging above 66 are more likely to vote than women at the same age group.




```{r eda_age_sex, include = FALSE}

```

The race of the registered voters is predominantly White (71 percent) and Black (20 percent). The average turnout rate across these two race are 69 percent and 64 percent respectively. The other races has varying voters turnout with the least for American Indians at 49 percent and highest among the Mixed race group at 79 percent, however they represented only a very small number of the total population. 

```{r eda_race, include = FALSE}
eda_race <- aggregate(sample_voting2016$actual_voters, by=list(sample_voting2016$race_code), FUN=sum)
colnames(eda_race) <- c("race_code", "actual_voters")
eda_race$non_voters <- aggregate(sample_voting2016$non_voters, by=list(sample_voting2016$race_code), FUN=sum)[,2]
eda_race$total_voters <- aggregate(sample_voting2016$total_voters, by=list(sample_voting2016$race_code), FUN=sum)[,2]
eda_race$voter_turnout <- eda_race$actual_voters/eda_race$total_voters
eda_race
# scatter binned plot: significant differences among different race groups, but unsure if biased due to insufficient data
ggplot(eda_race,
       aes(y=voter_turnout,x=race_code,color=race_code))+
  geom_point()+
  ylim(0.5, 0.9)
```

The voter population is evenly spreadout across different party affiliations, except for the people affiliated to the Libertarian party (only 0.2 percent). The voting turnout rate was highest for Republicans at 74 percent and Democrats turnout was 66 percent. There were approximately 28 percent of the total population who were not affiliated to any party and their voting turnout was relatively lower than the other parties at around 61 percent. 

```{r eda_aff, include = FALSE}
eda_party <- aggregate(sample_voting2016$actual_voters, by=list(sample_voting2016$party_cd), FUN=sum)
colnames(eda_party) <- c("party_cd", "actual_voters")
eda_party$non_voters <- aggregate(sample_voting2016$non_voters, by=list(sample_voting2016$party_cd), FUN=sum)[,2]
eda_party$total_voters <- aggregate(sample_voting2016$total_voters, by=list(sample_voting2016$party_cd), FUN=sum)[,2]
eda_party$voter_turnout <- eda_party$actual_voters/eda_party$total_voters
eda_party
# scatter binned plot: significant differences between dem and rep
ggplot(eda_party,
       aes(y=voter_turnout,x=party_cd,color=party_cd))+
  geom_point()+
  ylim(0.5, 0.9)
```

The voting turnout between genders varied across different party affiliations. For the Democrates, females are having distinct higher turnout rate compared to males. However, it was observed that for Republican, Libertarian and Unaffiliated, both genders have similar turnout rates. This trend seems plausible because the contestants for the 2016 presendial election was a Republican male candidate and Democrat female candidate.

```{r eda_aff_sex, include = FALSE}
eda_party_sex <- aggregate(sample_voting2016$actual_voters, by=list(sample_voting2016$party_cd, sample_voting2016$sex_code), FUN=sum)
colnames(eda_party_sex) <- c("party_cd","sex_code", "actual_voters")
eda_party_sex$non_voters <- aggregate(sample_voting2016$non_voters, by=list(sample_voting2016$party_cd, sample_voting2016$sex_code), FUN=sum)[,3]
eda_party_sex$total_voters <- aggregate(sample_voting2016$total_voters, by=list(sample_voting2016$party_cd, sample_voting2016$sex_code), FUN=sum)[,3]
eda_party_sex$voter_turnout <- eda_party_sex$actual_voters/eda_party_sex$total_voters
eda_party_sex
# scatter binned plot: significantly different distribution among different counties
ggplot(eda_party_sex,
       aes(y=voter_turnout,x=party_cd,color=sex_code))+
  geom_point()+
  ylim(0.5, 0.9)
```

# 3. Model
By including all demographic variables and the interaction term of party with sex and age with sex as random effect, the final model selected through selection using AIC and AUC value as the model selection criteria, is as below:

$$logit(Pr[vote_i=1]) = \beta_0 + \gamma^{county}_{0m[i]} + \beta_{1} {sex_i}  + \beta_{2} {age_i} + \beta_{3} {race_i} + \beta_{4} {ethnic_i} + \beta_{5} {party_i} + \\ \beta_{6} {sex_i:party_{cd_{i}}} + \beta_{7} {sex_{i}:age_{i}} \\ \gamma^{county_{desc}}_{0m[i]} \sim N(0,\tau^2) \\ \epsilon_{i,j} \overset{iid}\sim N(0,\sigma^2)$$

The predictors variables selected include five main demographic variables (sex, age, race, ethnic, party), two interaction terms (sex and age, sex and party), and county as random intercept, all of which were consistent with the EDA findings of each predictor variables. 
Based on the multilevel logistic regression output, a non-hispanic or non-latino white female aged 18-25 from Democratic party has 55 percent chance of turning out to vote, which is set as the baseline reference. Compared with white people, black or african americans have 3 percent higher odds, asians have 21 percent higher odds, people from mixed race have around 1.8 times more higher odds, american indians or alaska natives have 35 percent higher odds, and people from other races have 9 percent higher odds of voting. Regarding ethnics, hispanic or latinos are 29 percent more likely to give actual vote compared with non-hispanic or non-latino people. Compared with people with party affliation being democratic given other covariates being constant, people more affliated with libertarians has one time more lilelihood of voting, republicans 35 percent more, and those unaffiliated are 16percent less likely to vote. Regarding age groups, for people who are age between 26 to 40, they are 16 percent more likely to actually vote, while people from age range 41 to 65 are 2.4 times more likely, and people aged aove 67 are 2.3 times more likely compared with people aged 18 to 25. It can be seen that older generation has around two times of the odds of voting compared to the younger generation.

Holding all other factors constant, males are generally 40percent less likely to vote than females. Regarding the interaction between sex and party, the odds of vote turnout for female is around 66percent more than male for democratic party, while for other parties including libertarians, republicans, and unaffiliated, the odds of vote turnout for female is around 23percent, 26percent, and 31percent more than males respectively. The odds from males to females are two times more for democrat compared to unaffiliated, and three times more compared to liberatians or republicans. For the interaction between sex and age, females are 66percent more to vote than males for people aging from 18 to 25, 56 percent more for people aging 26 to 40, and 34 percent more for those aged 41 to 65. On the other hand, the odds of voting for males overtakes females by 10 percent for people aged over 66. It can be seen that for older age groups, the differential likelihood of voting of females compared to males decreases, which agrees with previous EDA findings.

>>>>>>below for checking/review purpose, use model3 (to delete)
f age18-25 exp(0.189960) = 1.209201
m age18-25 exp(0.189960)*exp(-0.508373) =  0.7273024
f age26-40 exp(0.189960)*exp(0.149504) = 1.404195
m age26-40 exp(0.189960)*exp(0.149504)*exp(-0.508373)*exp(0.064826) = 0.9011505
f age41-65 exp(0.189960)*exp(0.883099) = 2.924311
m age41-65 exp(0.189960)*exp(0.883098)*exp(-0.508373)*exp(0.214858) = 2.180476
f age>66 exp(0.189960)*exp(0.850625) =2.830873
m age>66 exp(0.189960)*exp(0.850625)*exp(-0.508373)*exp(0.608266) = 3.128263


```{r finalModel, include=FALSE, eval=FALSE}
# FINAL MODEL: all 5 demo variables + random effect on county + sex:party + sex:age
sample_voting2016$party_cd = relevel(sample_voting2016$party_cd, "DEM")
sample_voting2016$race_code = relevel(sample_voting2016$race_code, "W")
sample_voting2016$sex_code = relevel(sample_voting2016$sex_code, "F")
sample_voting2016$ethnic_code = relevel(sample_voting2016$ethnic_code, "NL")
sample_voting2016$age = relevel(sample_voting2016$age, "Age 18 - 25")


model3 <- glmer(cbind(actual_voters,non_voters) ~ sex_code + age + race_code + ethnic_code + party_cd + (1|county_desc) + sex_code:party_cd + sex_code:age,family=binomial(link="logit"),data=sample_voting2016,
                control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
summary(model3)
```

### Model Building Process

The methodology adopted in the model building was initialized with the variable selection of all demographic variables using AIC, BIC, and AUC values as the judgement criteria. All the five demographic subgroups -  sex, age, race, ethnic and party were included as the fixed-effects, with the county as the random effect in the initial base model (model1). 

Based on the EDA, there was a significant difference in turnout for different counties. Therefore, the variable 'county' was included as a classifier to account for random intercept across counties. As each of the five demographic subgroups was of key research interest, they were first included as a fixed effect. These variables were retained for the model building as all proved to be significant.

The Interaction of sex with party and sex with age were subsequently added one by one on top of the base model and were tested for significance via change in deviance tests. When including precinct as a nested level within county, there was convergence problem likely due to a lack of data in some interaction subgroups. In order to have information on the fixed effects of individual predictors of interest (age, party, and sex), the interactions were included as fixed effects with county alone set as classifier with no slope specified.

Model statistics of Accuracy, Sensitivity, and Specificity were also used to validate and compare each intermediate model. It was shown that by incorporating the two interaction terms, there was noticeable increase in accuracy, with decrease in the AIC and BIC score. As each precinct was assumed to be uniquely linked with a particular county, there existed two levels of hierarchy. With nested levels, there was a significant decrease in AIC and BIC values, and an increase in accuracy, and specificity, hence it was chosen as the final model.


```{r glm_table, include=FALSE, eval=FALSE}
glm_table <-data.frame(c("Model 1", "Model 2", "Model 3", "Model 4"),
                       rep(0,4), rep(0,4), rep(0,4),rep(0,4),rep(0,4),rep(0,4))
colnames(glm_table) <- c("Model","Forumula","AIC","BIC","Accuracy","Sensitivity",
                         "Specificity")

# fixed effects on all 5 demo variables + random effects on county
formula1 = cbind(actual_voters,non_voters) ~ sex_code + age + race_code + ethnic_code + party_cd + (1|county_desc)
# fixed effects on all 5 demo variables & interaction of sex:party + random effects on county 
formula2 = update(formula1, ~ . + sex_code:party_cd)
# fixed effects on all 5 demo variables & interaction of sex:party and sex:age
# + random effects on county 
formula3 = update(formula2, ~ . + sex_code:age)
# fixed effects on all 5 demo variables & interaction of sex:party and sex:age
# + random effects on county/precinct (nested)
formula4 = update(formula3, ~ . - (1|county_desc) + (1|county_desc/precinct_abbrv))

formula_list = c(formula1, formula2, formula3, formula4)
model = list()
summary = list()
fixef = list()
ranef = list()
tab_model = list()
newdata = list()
roc = list()
conf_mat = list()

for (formula in formula_list) {
  index = match(c(formula), formula_list)
  # Regression Results 
  model_i <- glmer(formula, family=binomial(link="logit"),data=sample_voting2016)
  model <- list.append(model, model_i)
  summary <- list.append(summary, summary(model_i))
  fixef <- list.append(fixef, fixef(model_i))
  ranef <- list.append(ranef, ranef(model_i))
  tab_model <- list.append(tab_model, tab_model(model_i))
  glm_table$Forumula[index] <- as.character(formula)
  # AIC, BIC
  glm_table$AIC[index] <- AIC(model_i)
  glm_table$BIC[index] <- BIC(model_i)
  
  # ROC, AUC
  # pred_i <- predict(model_i, type="response")
  # pred_i <- data.frame(cbind(sample_voting2016$actual_voters, sample_voting2016$non_voters, pred=pred_i))
  # 
  # vote_yes <- pred_i[rep(row.names(pred_i), pred_i$actual_voters),]
  # vote_yes$obs <- 1
  # vote_no <- pred_i[rep(row.names(pred_i), pred_i$non_voters),]
  # vote_no$obs <- 0
  # newdata_i <- rbind(vote_yes, vote_no)[, c("pred", "obs")]
  # newdata <- list.append(newdata, newdata_i)
  # roc_i <- roc(newdata_i$obs,newdata_i$pred,plot=T,print.thres="best",legacy.axes=T,
  #            print.auc =T,col="red3")
  # roc.name = paste("roc", toString(index), sep = "")
  # assign(roc.name, roc_i)
  # glm_table$AUC[index] <- auc(roc_i)
  pred_i <- predict(model_i, type="response")
  pred_i <- data.frame(cbind(obs_actual=sample_voting2016$actual_voters, 
                             obs_non=sample_voting2016$non_voters,
                             total_voters=sample_voting2016$total_voters, predp=pred_i))
  pred_i$pred_actual <- round(pred_i$total_voters*pred_i$predp)
  pred_i$pred_non <- pred_i$total_voters - pred_i$pred_actual
  pred_i$diff <- pred_i$obs_actual - pred_i$pred_actual
  
  vote_yes <- pred_i[rep(row.names(pred_i), pmin(pred_i$obs_actual,pred_i$pred_actual)),]
  vote_yes[,c("obs", "pred")] <- c(1,1)
  vote_no <- pred_i[rep(row.names(pred_i), pmin(pred_i$obs_non,pred_i$pred_non)),]
  vote_no[,c("obs", "pred")] <- c(0,0)
  vote_diff <- pred_i[rep(row.names(pred_i), abs(pred_i$diff)),]
  vote_diff[,c("obs", "pred")] <- c(as.numeric(vote_diff$diff>0),1-as.numeric(vote_diff$diff>0))
  newdata_i <- rbind(vote_yes, vote_no, vote_diff)[, c("obs", "pred")]
  
  newdata <- list.append(newdata, newdata_i)
  
  # Threshold, Accuracy, Sensitivity, Specificity
  # glm_table$Threshold[index] <- coords(roc_i, "best", ret = "threshold")
  # glm_table$Accuracy[index] <- coords(roc_i, "best", ret = "accuracy")
  # glm_table$Sensitivity[index] <- coords(roc_i, "best", ret = "sensitivity")
  # glm_table$Specificity[index] <- coords(roc_i, "best", ret = "specificity")
  
  # Confusion Matrix
  # conf_mat_i <- confusionMatrix(as.factor(ifelse(newdata_i$pred >= as.numeric(glm_table$Threshold[index]), "1","0")),
  #                             as.factor(newdata_i$obs),positive = "1")
  conf_mat_i <- confusionMatrix(as.factor(newdata_i$pred),as.factor(newdata_i$obs),positive = "1")
  conf_mat <- list.append(conf_mat, conf_mat_i$table)
  glm_table$Accuracy[index] <- conf_mat_i$overall["Accuracy"]
  glm_table$Sensitivity[index] <- conf_mat_i$byClass["Sensitivity"]
  glm_table$Specificity[index] <- conf_mat_i$byClass["Specificity"]
}

(glm_table)

```

```{r finalModel, echo=FALSE, message=FALSE}
#reference level: NL, W, F, aged 18-25, dem
kable(tidy(model3),caption="Logistic Regression Results for Final Model", digits = 5, format="markdown")
```

```{r modelAssess_dotplot, include = FALSE}
# dotplot
dotplot(ranef(model3, condVar=TRUE))
```


# 4. Results

The confusion matrix is defined for the model. The cut-off value was reset according to the ROC curve's best threshold of 0.660. The final model can predict the true positives and true negatives proportionally with an overall accuracy of 65.37 percent. The optimal sensitivity and specificity suggest that the model is 70.5 percent correct at identifying true positives (i.e. actual_voters), and 54.7 percent correct identifying true negatives (i.e. non-voters). The estimated AUC based on the ROC curve is 0.673, which suggests the model is 67.3percent well at successfully predicting whether a person will turn up based on the given demographic characteristics of that person (age, race_code, ethnic_code, county_desc, precinct_abbrv, sex_code, party_cd). The model performs better by including the random effect of sex with age in accuracy and sensitivity.

Further, the standard deviation of county as random effects is 0.2355, suggesting that voting turnout varies to a relatively large extent across counties. In line with the previous EDA findings, it was found out from the final model that sex alone was not statistically significant in affecting the voters turnout outcome, and people above 41 years old appeared more likely to affect the turnout rate with high significance compared to people who were below 40 years old. 


# 5. Conclusion

It is found from the multilevel logistic regression using county as the grouping classifier that the overall probability or odds of voting differs to a relatively large extent across different counties in 2016.

Further, the five main demographic variables (sex, age, race, ethnic, party) and two interaction terms (sex and age, sex and party) are all significant except subgroups in interations of undesignated sex affliating libertarian and undesignated sex in age group 41 to 65. Generally, males are 40 percent less likely to vote than females. The older generation are more likely to vote where people above 40 is more than two times likely to vote compared to younger people below. People who are two or more races or Asians are most likely to vote, of 1.8 times or 21 percent higher odds compared to white people respectively. Regarding ethnics, hispanic or latinos are 29 percent more likely to give votes compared with non-hispanic or non-latino people. In terms of party affliation, people more affliated with libertarians are more likely to vote with one time more than democrat, republicans 35 percent more while the unaffliiated is less likely. 

Considering how turnout rates differ between females and males for different party affiliations, the odds from males to females are two times more for democrat (66 percent) compared to unaffilicated, three times more compared to liberatians or republicans, and two times more than the unaffliated.


# 6. Limitations

There were several limiations in the study which lead to not accuractely determining the odds of voters turnout. Firstly, the age was categorically represented into 4 groups. This could have lead to biased results for people sharing the same age group. Secondly, there were counties which had more number of actual voters than regisered for those counties. This could have been a result of gerrymandering, but no information was provided. There were about 1.3 precent of people who did not have a binary gender specified and could have been among the binary gender classification. There could have been other external factors like advertising budget across different counties for the election or the accessibility of polling stations for people. These factors could also impacted the final results if such information was provided. 


# 7. Remarks


\newpage
# 8. Appendix

# Appendix 1
## Counties
ALAMANCE, ROBESON, CATAWBA, GATES, LINCOLN, ROCKINGHAM, ONSLOW, VANCE, BLADEN,  WILSON, 
DUPLIN, NORTHAMPTON BURKE, GRAHAM,  CHATHAM, CASWELL, YANCEY,  JONES, SWAIN, CHEROKEE 


# Appendix 2
## Code
```{r codeReorganize, include=FALSE}
# load libraries
library(dplyr)
library(ggplot2)
library(gridExtra) # for grid.arrange(): combine ggplots
library(lme4) # for glmer(): hierarchical logistics regression
library(rstan)
library(brms)
library(sjPlot) # for tab_model()
library(pROC) # for roc()
library(arm) # for binnedplot()
library(e1071)
library(caret) # for confusionMatrix()
library(rlist) # for list.append()
library(lattice) # for dotplot()
library(kableExtra) # for kable()

##### Data cleaning #####

### step1: load data

# set pwd to git directory
getwd()
setwd('../')
getwd()

# load actual voters data --> 734126 rows
voted <- read.delim("Data/Part_2/history_stats_20161108.txt", header = TRUE, sep = "\t")
summary(voted)

# load registered voters data --> 514844 rows
registered <- read.delim("Data/Part_2/voter_stats_20161108.txt", header = TRUE, sep = " ", quote = "\"")
summary(registered)

### step 2: remove unnecessary rows

# remove duplicate rows(if any), and save into new df 
voted_cleaned <- unique(voted)
registered_cleaned <- unique(registered)
# remove na (if any)
voted_cleaned <- na.omit(voted_cleaned)
registered_cleaned <- na.omit(registered_cleaned)
# remove rows with empty string "" and " "
voted_cleaned <- voted_cleaned[!apply(voted_cleaned, 1, function(x) any(x=="")),] # 704102 rows (1140 rows removed)
voted_cleaned <- voted_cleaned[!apply(voted_cleaned, 1, function(x) any(x==" ")),] # 704095 rows (7 rows removed)
registered_cleaned <- registered_cleaned[!apply(registered_cleaned, 1, function(x) any(x=="")),] # 513708 rows (1140 rows removed)
registered_cleaned <- registered_cleaned[!apply(registered_cleaned, 1, function(x) any(x==" ")),] # 513708 rows (0 rows removed)
# drop unused levels
voted_cleaned <- droplevels(voted_cleaned)
registered_cleaned <- droplevels(registered_cleaned)

### step 3: rename and remove unnecessary columns

# drop voted party_cd column (duplicate with voted_party_cd), election_date, update_date, 
# stats_type, voting_method, voting_method_desc column
voted_cleaned <- subset(voted_cleaned, select = -c(party_cd, election_date, update_date, 
                                                   stats_type, voting_method, voting_method_desc))
# drop registered election_date, stats_type column
registered_cleaned <- subset(registered_cleaned, select = -c(election_date, stats_type))

# rename voted voted_party_cd to party_cd to align naming with registered
colnames(voted_cleaned)[colnames(voted_cleaned)=="voted_party_cd"] <- "party_cd"
# rename voted total_voters to actual_voters to avoid same name with registered
colnames(voted_cleaned)[colnames(voted_cleaned)=="total_voters"] <- "actual_voters"

### step 4: check every common (joint) variable if levels match (8 variables in total)

# for loop for every variable
to_remove_variable_list = c("total_voters")
variable_list = colnames(registered_cleaned)
variable_list <- variable_list[-match(to_remove_variable_list, variable_list)]
check_level <- data.frame(variable_list, check_level = rep(FALSE, length(variable_list)))

for (variable in variable_list){
  index = match(c(variable), variable_list)
  check_level[index,2] <- all(levels(voted_cleaned[,variable]) == levels(registered_cleaned[,variable]))
}
check_level

# age and sex_code levels do not match
# removed extra levels in voted
voted_cleaned <- voted_cleaned[!(voted_cleaned$age == "Age < 18 Or Invalid Birth Dates"), ] # 704094 rows (1 rows removed)
voted_cleaned <- voted_cleaned[!(voted_cleaned$sex_code == "N"), ] # 704093 rows (1 rows removed)
# drop unused levels
voted_cleaned <- droplevels(voted_cleaned)
registered_cleaned <- droplevels(registered_cleaned)
# re-run for loop to check if levels match

### step 5: aggregate voted after removing voting_method

# check for duplicate rows
any(duplicated(registered_cleaned))
any(duplicated(voted_cleaned))
# aggregate actual_voters based on 8 demo variables in voted, resave into new df --> 403343 rows
aggregate_list = list()
for (variable in variable_list){
  aggregate_list <- list.append(aggregate_list, voted_cleaned[,variable])
}
voted_cleaned_agg <- aggregate(voted_cleaned$actual_voters, by=aggregate_list, FUN=sum)
colnames(voted_cleaned_agg) <- c(variable_list, "actual_voters")

### step 6: merging and sample

# merge voted_cleaned_agg with registered_cleaned --> 397687 rows with 10 variables
voting2016 <- inner_join(voted_cleaned_agg, registered_cleaned)
# select 20 random counties --> 48720 rows
set.seed(1000)
sample_county <- sample(unique(voting2016$county_desc), 20, replace=F)
sample_voting2016 <- voting2016[is.element(voting2016$county_desc, sample_county),]
# remove unused levels
sample_voting2016 <- droplevels(sample_voting2016)
# data summary
summary(sample_voting2016)
str(sample_voting2016)

### step 7: remove rows with actual_voters > total_voters

# new column for number of non voters
sample_voting2016$non_voters <- sample_voting2016$total_voters - sample_voting2016$actual_voters
# 363 rows with -ve non voter counts: actual voters more than total 
nrow(sample_voting2016[sample_voting2016$non_voters<0,])
# remove and save --> 48357 rows
sample_voting2016 <- sample_voting2016[!(sample_voting2016$non_voters<0), ]

### step 8: export clean datasets to csv

# write.csv(sample_voting2016, file = "sample_voting2016.csv")
# write.csv(voting2016, file = "voting2016.csv")
# write.csv(voted_cleaned_agg, file = "voted_cleaned_agg.csv")
# write.csv(voted_cleaned, file = "voted_cleaned.csv")
# write.csv(registered_cleaned, file = "registered_cleaned.csv")

# ***********************************************************************************

##### Exploratory data analysis #####

# response variable: percent distribution of voters vs nonvoters: 68:32
sum(sample_voting2016$actual_voters)/sum(sample_voting2016$total_voters)
sum(sample_voting2016$non_voters)/sum(sample_voting2016$total_voters)

### eda for each of county & 5 demo variables: sex_code, age, ethnic_code, race_code, party_cd

to_remove_predictor_list = c("actual_voters", "total_voters", "non_voters")
predictor_list <- colnames(sample_voting2016)
predictor_list <- predictor_list[-match(to_remove_predictor_list, predictor_list)]

for (predictor in predictor_list) {
  
  eda_i <- aggregate(sample_voting2016$actual_voters, by=list(sample_voting2016[,predictor]), FUN=sum)
  colnames(eda_i) <- c(predictor, "actual_voters")
  eda_i$non_voters <- aggregate(sample_voting2016$non_voters, by=list(sample_voting2016[,predictor]), FUN=sum)[,2]
  eda_i$total_voters <- aggregate(sample_voting2016$total_voters, by=list(sample_voting2016[,predictor]), FUN=sum)[,2]
  eda_i$voter_turnout <- eda_i$actual_voters/eda_i$total_voters
  eda_i$per_total_voters <- eda_i$total_voters/sum(eda_i$total_voters)
  eda_df.name = paste("eda", toString(predictor), sep = "_")
  assign(eda_df.name, eda_i)
  
  gg_i <- ggplot(eda_i,
         aes(y=voter_turnout,x=.data[[predictor]],color=.data[[predictor]]))+
    geom_point(aes(size=total_voters), alpha=0.7)+
    scale_size_continuous(range = c(5, 20))+
    ylim(0.4, 0.9)+
    xlab(predictor)+
    labs(color = predictor)+
    guides(size=FALSE)
  gg.name = paste("gg", toString(predictor), sep = "_")
  assign(gg.name, gg_i)
}

grid.arrange(gg_county_desc, gg_party_cd, gg_race_code, gg_ethnic_code, gg_sex_code, gg_age, 
               widths = c(1, 1, 1, 1.5),
               layout_matrix = rbind(c(1, 1, 1, 3),
                                     c(2, 4, 5, 6)))

### eda for nested location variables: county_desc:precinct_abbrv

nested_list = data.frame(c("county_desc", "precinct_abbrv"))

for (nested in nested_list) {
  
  var1 = toString(nested[1])
  var2 = toString(nested[2])
  eda_i <- aggregate(sample_voting2016$actual_voters, by=list(sample_voting2016[,var1], sample_voting2016[,var2]), FUN=sum)
  colnames(eda_i) <- c(var1, var2, "actual_voters")
  eda_i$non_voters <- aggregate(sample_voting2016$non_voters, by=list(sample_voting2016[,var1], sample_voting2016[,var2]), FUN=sum)[,3]
  eda_i$total_voters <- aggregate(sample_voting2016$total_voters, by=list(sample_voting2016[,var1], sample_voting2016[,var2]), FUN=sum)[,3]
  eda_i$voter_turnout <- eda_i$actual_voters/eda_i$total_voters
  eda_i$per_total_voters <- eda_i$total_voters/sum(eda_i$total_voters)
  eda_df.name = paste("eda", var1, var2, sep = "_")
  assign(eda_df.name, eda_i)
  
  eda_count_i <- eda_i percent>percent
    group_by(.data[[var1]]) percent>percent
    summarise(no_rows = length(.data[[var1]]))
  eda_count_i <- data.frame(eda_count_i)
  eda_count_df.name = paste("eda_count", var1, var2, sep = "_")
  assign(eda_count_df.name, eda_count_i)
  
  gg_i <- ggplot(eda_i,
                 aes(y=voter_turnout,x=.data[[var1]],fill=.data[[var1]]))+
    geom_boxplot()+
    ylim(0.4, 0.9)+
    xlab(var1)+
    labs(fill = var1)+
    guides(size=FALSE)
  gg.name = paste("gg", var1, var2, sep = "_")
  assign(gg.name, gg_i)
}

### eda for interaction term: party_cd:sex_code, age:sex_code

interaction_list = data.frame(c("party_cd", "sex_code"), 
                              c("age", "sex_code"))

for (interaction in interaction_list) {
  
  var1 = toString(interaction[1])
  var2 = toString(interaction[2])
  eda_i <- aggregate(sample_voting2016$actual_voters, by=list(sample_voting2016[,var1], sample_voting2016[,var2]), FUN=sum)
  colnames(eda_i) <- c(var1, var2, "actual_voters")
  eda_i$non_voters <- aggregate(sample_voting2016$non_voters, by=list(sample_voting2016[,var1], sample_voting2016[,var2]), FUN=sum)[,3]
  eda_i$total_voters <- aggregate(sample_voting2016$total_voters, by=list(sample_voting2016[,var1], sample_voting2016[,var2]), FUN=sum)[,3]
  eda_i$voter_turnout <- eda_i$actual_voters/eda_i$total_voters
  eda_i <- eda_i percent>percent
    group_by(.data[[var1]]) percent>percent
    mutate(per_total_voters = (total_voters/sum(total_voters)))
  eda_i <- data.frame(eda_i)
  eda_i <- eda_i[order(eda_i[,var1]), ]
  eda_df.name = paste("eda", var1, var2, sep = "_")
  assign(eda_df.name, eda_i)
  
  gg_i <- ggplot(eda_i,
                 aes(y=voter_turnout,x=.data[[var1]],color=.data[[var2]]))+
    geom_point(aes(size=total_voters), alpha=0.7)+
    scale_size_continuous(range = c(5, 20))+
    ylim(0.4, 0.9)+
    xlab(var1)+
    labs(color = var2)+
    guides(size=FALSE)
  gg.name = paste("gg", var1, var2, sep = "_")
  assign(gg.name, gg_i)
}

grid.arrange(gg_county_desc_precinct_abbrv, gg_party_cd_sex_code, gg_age_sex_code, 
             widths = c(1, 1),
             layout_matrix = rbind(c(1, 1),
                                   c(2, 3)))

# *********************************************************************************

##### Model Building #####

# glm_table <-data.frame(c("Model 1", "Model 2", "Model 3", "Model 4"), 
#                        rep(0,4), rep(0,4),rep(0,4),rep(0,4),rep(0,4),rep(0,4),rep(0,4))
# colnames(glm_table) <- c("Model","AIC","BIC","AUC","Threshold","Accuracy","Sensitivity", 
#                          "Specificity")

glm_table <-data.frame(c("Model 1", "Model 2", "Model 3", "Model 4"),
                       rep(0,4), rep(0,4),rep(0,4),rep(0,4),rep(0,4))
colnames(glm_table) <- c("Model","AIC","BIC","Accuracy","Sensitivity",
                         "Specificity")

# fixed effects on all 5 demo variables + random effects on county
formula1 = cbind(actual_voters,non_voters) ~ sex_code + age + race_code + ethnic_code + party_cd + (1|county_desc)
# fixed effects on all 5 demo variables & interaction of sex:party + random effects on county 
formula2 = update(formula1, ~ . + sex_code:party_cd)
# fixed effects on all 5 demo variables & interaction of sex:party and sex:age
# + random effects on county 
formula3 = update(formula2, ~ . + sex_code:age)
# fixed effects on all 5 demo variables & interaction of sex:party and sex:age
# + random effects on county/precinct (nested)
formula4 = update(formula3, ~ . - (1|county_desc) + (1|county_desc/precinct_abbrv))

formula_list = c(formula1, formula2, formula3, formula4)
model = list()
summary = list()
fixef = list()
ranef = list()
tab_model = list()
newdata = list()
roc = list()
conf_mat = list()

for (formula in formula_list[1]) {
  index = match(c(formula), formula_list)
  # Regression Results 
  model_i <- glmer(formula, family=binomial(link="logit"),data=sample_voting2016)
  model <- list.append(model, model_i)
  summary <- list.append(summary, summary(model_i))
  fixef <- list.append(fixef, fixef(model_i))
  ranef <- list.append(ranef, ranef(model_i))
  tab_model <- list.append(tab_model, tab_model(model_i))
  
  # AIC, BIC
  glm_table$AIC[index] <- AIC(model_i)
  glm_table$BIC[index] <- BIC(model_i)
  
  # ROC, AUC
  # pred_i <- predict(model_i, type="response")
  # pred_i <- data.frame(cbind(sample_voting2016$actual_voters, sample_voting2016$non_voters, pred=pred_i))
  # 
  # vote_yes <- pred_i[rep(row.names(pred_i), pred_i$actual_voters),]
  # vote_yes$obs <- 1
  # vote_no <- pred_i[rep(row.names(pred_i), pred_i$non_voters),]
  # vote_no$obs <- 0
  # newdata_i <- rbind(vote_yes, vote_no)[, c("pred", "obs")]
  # newdata <- list.append(newdata, newdata_i)
  # roc_i <- roc(newdata_i$obs,newdata_i$pred,plot=T,print.thres="best",legacy.axes=T,
  #            print.auc =T,col="red3")
  # roc.name = paste("roc", toString(index), sep = "")
  # assign(roc.name, roc_i)
  # glm_table$AUC[index] <- auc(roc_i)
  pred_i <- predict(model_i, type="response")
  pred_i <- data.frame(cbind(obs_actual=sample_voting2016$actual_voters, 
                             obs_non=sample_voting2016$non_voters,
                             total_voters=sample_voting2016$total_voters, predp=pred_i))
  pred_i$pred_actual <- round(pred_i$total_voters*pred_i$predp)
  pred_i$pred_non <- pred_i$total_voters - pred_i$pred_actual
  pred_i$diff <- pred_i$obs_actual - pred_i$pred_actual
  
  vote_yes <- pred_i[rep(row.names(pred_i), pmin(pred_i$obs_actual,pred_i$pred_actual)),]
  vote_yes[,c("obs", "pred")] <- c(1,1)
  vote_no <- pred_i[rep(row.names(pred_i), pmin(pred_i$obs_non,pred_i$pred_non)),]
  vote_no[,c("obs", "pred")] <- c(0,0)
  vote_diff <- pred_i[rep(row.names(pred_i), abs(pred_i$diff)),]
  vote_diff[,c("obs", "pred")] <- c(as.numeric(vote_diff$diff>0),1-as.numeric(vote_diff$diff>0))
  newdata_i <- rbind(vote_yes, vote_no, vote_diff)[, c("obs", "pred")]
  
  newdata <- list.append(newdata, newdata_i)
  
  # Threshold, Accuracy, Sensitivity, Specificity
  # glm_table$Threshold[index] <- coords(roc_i, "best", ret = "threshold")
  # glm_table$Accuracy[index] <- coords(roc_i, "best", ret = "accuracy")
  # glm_table$Sensitivity[index] <- coords(roc_i, "best", ret = "sensitivity")
  # glm_table$Specificity[index] <- coords(roc_i, "best", ret = "specificity")
  
  # Confusion Matrix
  # conf_mat_i <- confusionMatrix(as.factor(ifelse(newdata_i$pred >= as.numeric(glm_table$Threshold[index]), "1","0")),
  #                             as.factor(newdata_i$obs),positive = "1")
  conf_mat_i <- confusionMatrix(as.factor(newdata_i$pred),as.factor(newdata_i$obs),positive = "1")
  conf_mat <- list.append(conf_mat, conf_mat_i$table)
  glm_table$Accuracy[index] <- conf_mat_i$overall["Accuracy"]
  glm_table$Sensitivity[index] <- conf_mat_i$byClass["Sensitivity"]
  glm_table$Specificity[index] <- conf_mat_i$byClass["Specificity"]
}

glm_table

# Binned Residual Plots
# par(mfrow=c(1,1)) 
# binnedplot(data.frame(newdata[3])$pred, data.frame(newdata[3])$pred-data.frame(newdata[3])$obs, col.pts="blue4", col.int="red3")
# test <- dotplot(ranef(model_i, condVar=TRUE))
# class(test)
```


```{r presentation, include=FALSE}
# for presentation
gg_age <- gg_age + theme(legend.position = "bottom") + xlab("") + ylab("")
gg_party_cd <- gg_party_cd + theme(legend.position = "bottom")  + xlab("") + ylab("")
grid.arrange(gg_age, gg_party_cd, 
             widths = c(1,0.9),
             layout_matrix = rbind(c(1, 2)))

gg_sex_code <- gg_sex_code + theme(legend.position = "none")
gg_party_cd_sex_code <- gg_party_cd_sex_code + theme(legend.position = "none")
grid.arrange(gg_sex_code, gg_party_cd_sex_code, gg_age_sex_code,
widths = c(1.5, 2, 2.5),
layout_matrix = rbind(c(1, 2, 3)))

gg_county_desc_precinct_abbrv <- gg_county_desc_precinct_abbrv + xlab("") + ylab("") + theme(plot.title = element_text(hjust = 0.5), legend.position = "none") + coord_flip()
grid.arrange(gg_county_desc_precinct_abbrv)
```

* * *